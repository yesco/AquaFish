<!DOCTYPE html>
<!-- based on http://mtschirs.github.io/js-objectdetect/examples/example_gesture_input.htm -->
<!-- using https://github.com/mtschirs/js-objectdetect -->
<html lang="en">
<head>
<meta charset="utf-8">
<title>Gesture Control Example</title>
		
<link rel='stylesheet' type='text/css' href='css/x3dom.css'></link>
<script src='js/x3dom.js'></script>
    
<script src="js/compatibility.js"></script>
<script src="js/smoother.js"></script>
	
<script src="../js/objectdetect.js"></script>
<script src="../js/objectdetect.handfist.js"></script>
	
<script src="js/jquery.js"></script>
<script src="../js/jquery.objectdetect.js"></script>
	
<script>
$(window).load(function() {
    
    var smoother = new Smoother([0.9995, 0.9995], [0, 0], 0);
    var canvas = $('<canvas style="position: fixed; z-index: 1001; top: 10px; right: 10px; opacity: 0.9">').get(0);
    var context = canvas.getContext('2d');
    var video = document.createElement('video');

    var startPoint = (Math.PI/180)*0;
    var endPoint = (Math.PI/180)*360;

    function draw(fish) {
        fish.life = fish.life || 30;
        fish.c = fish.c || "rgba(" + 0 + "," + 0 + "," + 0 + "," + 255 + ")";

        // essentially draw a filled circle using ctx.arc
        context.fillStyle = fish.c;
        context.beginPath();
        context.arc(fish.x, fish.y, fish.life, startPoint, endPoint, true);
        context.fill();
        context.closePath();
    }

    var POS = {x: 0, y: 0, ms: 0};
    var LAST = POS;

    var fishes = [];

    function releaseFish(fish) {
        fishes.push(fish);
    }

    function drawAll() {
        fishes = fishes.filter(function(fish){
          draw(fish);
          fish.life--
          return fish.life > 0; // true to keep, otherwise dead
        });
    }

    document.getElementsByTagName('body')[0].appendChild(canvas);
    
    try {
	compatibility.getUserMedia({video: true}, function(stream) {
	    try {
		video.src = compatibility.URL.createObjectURL(stream);
	    } catch (error) {
		video.src = stream;
	    }
	    compatibility.requestAnimationFrame(play);
	}, function (error) {
	    alert("WebRTC not available");
	});
    } catch (error) {
	alert(error);
    }
    
    var fist_pos_old, angle = [0, 0];
    
    function play() {
	compatibility.requestAnimationFrame(play);
	if (video.paused) video.play();
	
        /* Draw video overlay */
	canvas.height = screen.height-100;
	canvas.width = ~~(canvas.height * video.videoWidth / video.videoHeight);

        //canvas.heigth = screen.heigth;
        //canvas.width = screen.width;

        // mirror video
        context.translate(canvas.clientWidth, 0);
        //context.translate(1000, 0);
        context.scale(-1, 1);

	context.drawImage(video, 0, 0, canvas.clientWidth, canvas.clientHeight);

	if (video.readyState === video.HAVE_ENOUGH_DATA) {
	    $(video).objectdetect("all", {size: 300, scaleMin: 3, scaleFactor: 1.1, classifier: objectdetect.handfist}, function(coords) {
		var fist_pos = coords[0] ?
		    [coords[0][0] + coords[0][2] / 2,
		     coords[0][1] + coords[0][3] / 2] : null;
		
		if (fist_pos && fist_pos_old) {
		    var dx = (fist_pos[0] - fist_pos_old[0]) / video.videoWidth;
		    var dy = (fist_pos[1] - fist_pos_old[1]) / video.videoHeight;
					  
		    if (dx*dx + dy*dy < 0.2) {
			angle[0] += 5.0 * dx;
			angle[1] += 5.0 * dy;
		    }
		}
		fist_pos_old = fist_pos;
		angle = smoother.smooth(angle);
				      
                // no hand
                if (!coords[0]) {
                    var ms = Date.now();
                    var dms = ms - POS.ms;
                    if (dms > 500) {
                        // change last one color and size
                        POS.life = 100;
                        POS.c = "rgba(255,255,255,255)";
                    }
		}
		
                // have hand
		if (coords[0]) {
                    var x = (coords[0][0]+coords[0][2]/2) / video.videoWidth * canvas.clientWidth;
                    var y = (coords[0][1]+coords[0][3]/2) / video.videoWidth * canvas.clientWidth;
                    var ms = Date.now();
                    PREV = POS;
                    LAST = POS;
                    POS = {x: x, y: y, ms: ms}

                    var dist = Math.abs(POS.x - LAST.x) + Math.abs(POS.y - LAST.y);
		    var dms = POS.ms - LAST.ms;

                    // filter out temp jumps
                    if (dms > 500 && dist > 100) {
                        // allow new pos
                        dms = 0;
                    }

                    if (dist < 100 || dms == 0) {
                        releaseFish(POS);
                    } else {
                        POS = PREV;
                    }

		    /* Draw coordinates on video overlay: */
		    context.beginPath();
		    context.lineWidth = '2';
		    context.fillStyle = 'rgba(0, 255, 255, 0.5)';
		    context.fillRect(
			coords[0][0] / video.videoWidth * canvas.clientWidth,
			coords[0][1] / video.videoHeight * canvas.clientHeight,
			coords[0][2] / video.videoWidth * canvas.clientWidth,
			coords[0][3] / video.videoHeight * canvas.clientHeight);
		    context.stroke();
		}
		
                drawAll();
		
	    });
	}
    }
});
</script>
</head>

<body>
<h1 style='text-align:center;font-size:60px;color:red;'>Aquarium</h1>
  
</body>
</html>
